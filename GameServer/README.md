
# 🛠 WarcraftGame

**WarcraftGame** — учебный прототип многопользовательской RTS в духе старых *Warcraft* или *Age of Empires*, сделанный на стеке **.NET + WebSocket + JS**.
Проект демонстрирует, как реализовать клиент-серверную синхронизацию, игровой цикл и визуализацию в реальном времени.

---

## 🚀 Архитектура

### Сервер (C# / ASP.NET Core)

Находится в папке `GameServer`.
Реализован как минимальное ASP.NET-приложение с поддержкой WebSocket-соединений.

Компоненты:

* **WebSocketAcceptor** — принимает подключения и создаёт `WebSocketSession` для каждого клиента.
* **WebSocketSession** — управляет общением с конкретным игроком, получает/отправляет JSON-сообщения.
* **SystemTextJsonSerializer** — сериализация/десериализация сообщений.
* **PlayerRegistry** — потокобезопасное хранилище подключённых игроков.
* **SnapshotService** — формирует первичный снапшот мира (игроки, сущности) после `join`.
* **IdGen** — безопасный генератор числовых ID.
* **Протокол сообщений** (в `Messages.cs`) — типизированные DTO: `PingMsg`, `PongMsg`, `JoinMsg`, `SnapshotMsg` и т.д.

Логика сервера минималистична: принимает `join`, регистрирует игрока, отсылает снапшот, отвечает на `ping`.

---

### Клиент (JavaScript)

Расположен в корне (`index.html`, `client.js`, `/core`, `/data`, `/render`, `/ui`).

Компоненты:

* **Network** — управляет WebSocket-соединением, пингом, отправкой команд и получением снапшотов.
* **World** — хранит текущее состояние мира (игроки, сущности).
* **Entity** — базовый класс игрового юнита с позицией, скоростью и HP.
* **Render** — двухслойный Canvas-рендерер с зумом, панорамированием и FPS-отчётом.
* **UI** — HUD, лог событий, окно подключения.
* **Model** — локальная модель симуляции: обрабатывает команды (spawn, move, kill и т.д.), выполняет тики, двигает юнитов, генерирует события.
* **Client bootstrap** (`client.js`) — связывает все части воедино.

---

## ⚙️ Принцип работы

1. Пользователь открывает `index.html`.
   Отображается окно входа с выбором имени и цвета.
2. После нажатия *«В игру»* клиент:

   * подключается к серверу через `WebSocket`;
   * отправляет `{ type: "join", name, color }`;
   * получает `snapshot` с текущими игроками.
3. Сервер хранит игроков и отвечает `pong` на пинги.
4. Клиентский рендер обновляется в реальном времени с расчётом FPS и камерой.
5. Локальная `Model` выполняет симуляцию мира с тикрейтом (TPS) и сглаживанием движений.

---

## 🧩 Пример JSON-протокола

```json
// Клиент → Сервер
{ "type": "join", "name": "Player1", "color": "red" }

// Сервер → Клиент
{
  "type": "snapshot",
  "time": 1760300066123,
  "myId": 1,
  "players": {
    "1": { "id": 1, "name": "Player1", "color": "red", "gold": 0, "wood": 0 }
  },
  "entities": {}
}

// Ping/Pong
{ "type": "ping", "clientTime": 1760300067000 }
{ "type": "pong", "serverTime": 1760300067020, "clientTime": 1760300067000 }
```

---

## 🧠 Технологии

* **Клиент:** чистый ES-модульный JavaScript, Canvas API, локальная симуляция.
* **Сервер:** .NET 8 (ASP.NET Core WebSockets), System.Text.Json.
* **Обмен:** WebSocket + JSON протокол.
* **Стиль:** простая HTML/CSS верстка без фреймворков.

---

## 🏃 Запуск

### Сервер

```bash
cd GameServer
dotnet run
```

Сервер поднимет HTTP-и WebSocket-эндпоинты (по умолчанию на `http://localhost:5000`).

### Клиент

Просто открой `index.html` в браузере (например, через VS Code Live Server или `python -m http.server`).

---

## 🧭 Структура проекта

```
GameServer/
 ├── Application/
 │    ├── ISender.cs
 │    ├── SnapshotService.cs
 ├── Domain/
 │    ├── Player.cs
 │    ├── PlayerRegistry.cs
 │    ├── IdGen.cs
 ├── Infra/
 │    ├── WebSocketAcceptor.cs
 │    ├── WebSocketSession.cs
 │    ├── SystemTextJsonSerializer.cs
 ├── Protocol/
 │    ├── Messages.cs
 │    ├── Json.cs
 │    ├── UnixMs.cs
 │    ├── IMessageSerializer.cs
 └── Program.cs (в AppHost)
client/
 ├── index.html
 ├── client.js
 ├── core/
 │    ├── network.js
 │    ├── model.js
 ├── data/
 │    ├── world.js
 │    ├── entity.js
 ├── render/
 │    ├── render.js
 └── ui/
      └── ui.js
```

---

## 🌐 Идея развития

* Реализовать серверную симуляцию мира.
* Добавить authoritative-синхронизацию (сервер диктует состояние, клиент интерполирует).
* Расширить команды: атака, добыча, строительство.
* Сохранение и восстановление состояния при потере соединения.
* Поддержка нескольких карт и типов юнитов.

---

## 🧾 Лицензия

MIT License.
Проект создаётся в образовательных целях
